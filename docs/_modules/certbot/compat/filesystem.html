

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>certbot.compat.filesystem &mdash; Certbot 1.16.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Certbot
          

          
          </a>

          
            
            
              <div class="version">
                1.16
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../what.html">What is a Certificate?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Get Certbot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../using.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../packaging.html">Packaging Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../compatibility.html">Backwards Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resources.html">Resources</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Certbot</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>certbot.compat.filesystem</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for certbot.compat.filesystem</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Compat module to handle files security on Windows and Linux&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">os</span>  <span class="c1"># pylint: disable=os-module-forbidden</span>
<span class="kn">import</span> <span class="nn">stat</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ntsecuritycon</span>
    <span class="kn">import</span> <span class="nn">win32security</span>
    <span class="kn">import</span> <span class="nn">win32con</span>
    <span class="kn">import</span> <span class="nn">win32api</span>
    <span class="kn">import</span> <span class="nn">win32file</span>
    <span class="kn">import</span> <span class="nn">pywintypes</span>
    <span class="kn">import</span> <span class="nn">winerror</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">POSIX_MODE</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">POSIX_MODE</span> <span class="o">=</span> <span class="kc">False</span>


<span class="c1"># Windows umask implementation, since Windows does not have a concept of umask by default.</span>
<span class="c1"># We choose 022 as initial value since it is the default one on most Linux distributions, and</span>
<span class="c1"># it is a decent choice to not have write permissions for group owner and everybody by default.</span>
<span class="c1"># We use a class here to avoid needing to define a global variable, and the potential mistakes</span>
<span class="c1"># that could happen with this kind of pattern.</span>
<span class="k">class</span> <span class="nc">_WindowsUmask</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Store the current umask to apply on Windows&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="mo">0o022</span>


<span class="n">_WINDOWS_UMASK</span> <span class="o">=</span> <span class="n">_WindowsUmask</span><span class="p">()</span>


<div class="viewcode-block" id="chmod"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.chmod">[docs]</a><span class="k">def</span> <span class="nf">chmod</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a POSIX mode on given file_path:</span>

<span class="sd">      - for Linux, the POSIX mode will be directly applied using chmod,</span>
<span class="sd">      - for Windows, the POSIX mode will be translated into a Windows DACL that make sense for</span>
<span class="sd">        Certbot context, and applied to the file using kernel calls.</span>

<span class="sd">    The definition of the Windows DACL that correspond to a POSIX mode, in the context of Certbot,</span>
<span class="sd">    is explained at https://github.com/certbot/certbot/issues/6356 and is implemented by the</span>
<span class="sd">    method `_generate_windows_flags()`.</span>

<span class="sd">    :param str file_path: Path of the file</span>
<span class="sd">    :param int mode: POSIX mode to apply</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_apply_win_mode</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="umask"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.umask">[docs]</a><span class="k">def</span> <span class="nf">umask</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the current numeric umask and return the previous umask. On Linux, the built-in umask</span>
<span class="sd">    method is used. On Windows, our Certbot-side implementation is used.</span>

<span class="sd">    :param int mask: The user file-creation mode mask to apply.</span>
<span class="sd">    :rtype: int</span>
<span class="sd">    :return: The previous umask value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">umask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="n">previous_umask</span> <span class="o">=</span> <span class="n">_WINDOWS_UMASK</span><span class="o">.</span><span class="n">mask</span>
    <span class="n">_WINDOWS_UMASK</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
    <span class="k">return</span> <span class="n">previous_umask</span></div>


<span class="c1"># One could ask why there is no copy_ownership() function, or even a reimplementation</span>
<span class="c1"># of os.chown() that would modify the ownership of file without touching the mode itself.</span>
<span class="c1"># This is because on Windows, it would require recalculating the existing DACL against</span>
<span class="c1"># the new owner, since the DACL is composed of ACEs that targets a specific user, not dynamically</span>
<span class="c1"># the current owner of a file. This action would be necessary to keep consistency between</span>
<span class="c1"># the POSIX mode applied to the file and the current owner of this file.</span>
<span class="c1"># Since copying and editing arbitrary DACL is very difficult, and since we actually know</span>
<span class="c1"># the mode to apply at the time the owner of a file should change, it is easier to just</span>
<span class="c1"># change the owner, then reapply the known mode, as copy_ownership_and_apply_mode() does.</span>
<div class="viewcode-block" id="copy_ownership_and_apply_mode"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.copy_ownership_and_apply_mode">[docs]</a><span class="k">def</span> <span class="nf">copy_ownership_and_apply_mode</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                  <span class="n">copy_user</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">copy_group</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy ownership (user and optionally group on Linux) from the source to the</span>
<span class="sd">    destination, then apply given mode in compatible way for Linux and Windows.</span>
<span class="sd">    This replaces the os.chown command.</span>

<span class="sd">    :param str src: Path of the source file</span>
<span class="sd">    :param str dst: Path of the destination file</span>
<span class="sd">    :param int mode: Permission mode to apply on the destination file</span>
<span class="sd">    :param bool copy_user: Copy user if `True`</span>
<span class="sd">    :param bool copy_group: Copy group if `True` on Linux (has no effect on Windows)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        <span class="n">user_id</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">st_uid</span> <span class="k">if</span> <span class="n">copy_user</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">group_id</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">st_gid</span> <span class="k">if</span> <span class="n">copy_group</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># On Windows, os.chown does not exist. This is checked through POSIX_MODE value,</span>
        <span class="c1"># but MyPy/PyLint does not know it and raises an error here on Windows.</span>
        <span class="c1"># We disable specifically the check to fix the issue.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chown</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">group_id</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">copy_user</span><span class="p">:</span>
        <span class="c1"># There is no group handling in Windows</span>
        <span class="n">_copy_win_ownership</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

    <span class="n">chmod</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>


<span class="c1"># Quite similar to copy_ownership_and_apply_mode, but this time the DACL is copied from</span>
<span class="c1"># the source file on Windows. The DACL stays consistent with the dynamic rights of the</span>
<span class="c1"># equivalent POSIX mode, because ownership and mode are copied altogether on the destination</span>
<span class="c1"># file, so no recomputing of the DACL against the new owner is needed, as it would be</span>
<span class="c1"># for a copy_ownership alone method.</span>
<div class="viewcode-block" id="copy_ownership_and_mode"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.copy_ownership_and_mode">[docs]</a><span class="k">def</span> <span class="nf">copy_ownership_and_mode</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                            <span class="n">copy_user</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">copy_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy ownership (user and optionally group on Linux) and mode/DACL</span>
<span class="sd">    from the source to the destination.</span>

<span class="sd">    :param str src: Path of the source file</span>
<span class="sd">    :param str dst: Path of the destination file</span>
<span class="sd">    :param bool copy_user: Copy user if `True`</span>
<span class="sd">    :param bool copy_group: Copy group if `True` on Linux (has no effect on Windows)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="c1"># On Linux, we just delegate to chown and chmod.</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        <span class="n">user_id</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">st_uid</span> <span class="k">if</span> <span class="n">copy_user</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">group_id</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">st_gid</span> <span class="k">if</span> <span class="n">copy_group</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chown</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">group_id</span><span class="p">)</span>
        <span class="n">chmod</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">copy_user</span><span class="p">:</span>
            <span class="c1"># There is no group handling in Windows</span>
            <span class="n">_copy_win_ownership</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
        <span class="n">_copy_win_mode</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span></div>


<div class="viewcode-block" id="check_mode"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.check_mode">[docs]</a><span class="k">def</span> <span class="nf">check_mode</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the given mode matches the permissions of the given file.</span>
<span class="sd">    On Linux, will make a direct comparison, on Windows, mode will be compared against</span>
<span class="sd">    the security model.</span>

<span class="sd">    :param str file_path: Path of the file</span>
<span class="sd">    :param int mode: POSIX mode to test</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    :return: True if the POSIX mode matches the file permissions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IMODE</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span> <span class="o">==</span> <span class="n">mode</span>

    <span class="k">return</span> <span class="n">_check_win_mode</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="check_owner"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.check_owner">[docs]</a><span class="k">def</span> <span class="nf">check_owner</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if given file is owned by current user.</span>

<span class="sd">    :param str file_path: File path to check</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    :return: True if given file is owned by current user, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="c1"># On Windows, os.getuid does not exist. This is checked through POSIX_MODE value,</span>
        <span class="c1"># but MyPy/PyLint does not know it and raises an error here on Windows.</span>
        <span class="c1"># We disable specifically the check to fix the issue.</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span><span class="o">.</span><span class="n">st_uid</span> <span class="o">==</span> <span class="n">os</span><span class="o">.</span><span class="n">getuid</span><span class="p">()</span>  <span class="c1"># type: ignore</span>

    <span class="c1"># Get owner sid of the file</span>
    <span class="n">security</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">OWNER_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">security</span><span class="o">.</span><span class="n">GetSecurityDescriptorOwner</span><span class="p">()</span>

    <span class="c1"># Compare sids</span>
    <span class="k">return</span> <span class="n">_get_current_user</span><span class="p">()</span> <span class="o">==</span> <span class="n">user</span></div>


<div class="viewcode-block" id="check_permissions"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.check_permissions">[docs]</a><span class="k">def</span> <span class="nf">check_permissions</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if given file has the given mode and is owned by current user.</span>

<span class="sd">    :param str file_path: File path to check</span>
<span class="sd">    :param int mode: POSIX mode to check</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    :return: True if file has correct mode and owner, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">check_owner</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">check_mode</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="open"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.open">[docs]</a><span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mo">0o777</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>  <span class="c1"># pylint: disable=redefined-builtin</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper of original os.open function, that will ensure on Windows that given mode</span>
<span class="sd">    is correctly applied.</span>

<span class="sd">    :param str file_path: The file path to open</span>
<span class="sd">    :param int flags: Flags to apply on file while opened</span>
<span class="sd">    :param int mode: POSIX mode to apply on file when opened,</span>
<span class="sd">        Python defaults will be applied if ``None``</span>
<span class="sd">    :returns: the file descriptor to the opened file</span>
<span class="sd">    :rtype: int</span>
<span class="sd">    :raise: OSError(errno.EEXIST) if the file already exists and os.O_CREAT &amp; os.O_EXCL are set,</span>
<span class="sd">            OSError(errno.EACCES) on Windows if the file already exists and is a directory, and</span>
<span class="sd">            os.O_CREAT is set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="c1"># On Linux, invoke os.open directly.</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="c1"># Windows: handle creation of the file atomically with proper permissions.</span>
    <span class="k">if</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">os</span><span class="o">.</span><span class="n">O_CREAT</span><span class="p">:</span>
        <span class="c1"># If os.O_EXCL is set, we will use the &quot;CREATE_NEW&quot;, that will raise an exception if</span>
        <span class="c1"># file exists, matching the API contract of this bit flag. Otherwise, we use</span>
        <span class="c1"># &quot;CREATE_ALWAYS&quot; that will always create the file whether it exists or not.</span>
        <span class="n">disposition</span> <span class="o">=</span> <span class="n">win32con</span><span class="o">.</span><span class="n">CREATE_NEW</span> <span class="k">if</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">os</span><span class="o">.</span><span class="n">O_EXCL</span> <span class="k">else</span> <span class="n">win32con</span><span class="o">.</span><span class="n">CREATE_ALWAYS</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">SECURITY_ATTRIBUTES</span><span class="p">()</span>
        <span class="n">security</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">SECURITY_DESCRIPTOR</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">_get_current_user</span><span class="p">()</span>
        <span class="n">dacl</span> <span class="o">=</span> <span class="n">_generate_dacl</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">_WINDOWS_UMASK</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="c1"># We set second parameter to 0 (`False`) to say that this security descriptor is</span>
        <span class="c1"># NOT constructed from a default mechanism, but is explicitly set by the user.</span>
        <span class="c1"># See https://docs.microsoft.com/en-us/windows/desktop/api/securitybaseapi/nf-securitybaseapi-setsecuritydescriptorowner  # pylint: disable=line-too-long</span>
        <span class="n">security</span><span class="o">.</span><span class="n">SetSecurityDescriptorOwner</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># We set first parameter to 1 (`True`) to say that this security descriptor contains</span>
        <span class="c1"># a DACL. Otherwise second and third parameters are ignored.</span>
        <span class="c1"># We set third parameter to 0 (`False`) to say that this security descriptor is</span>
        <span class="c1"># NOT constructed from a default mechanism, but is explicitly set by the user.</span>
        <span class="c1"># See https://docs.microsoft.com/en-us/windows/desktop/api/securitybaseapi/nf-securitybaseapi-setsecuritydescriptordacl  # pylint: disable=line-too-long</span>
        <span class="n">security</span><span class="o">.</span><span class="n">SetSecurityDescriptorDacl</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dacl</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">handle</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">handle</span> <span class="o">=</span> <span class="n">win32file</span><span class="o">.</span><span class="n">CreateFile</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">win32file</span><span class="o">.</span><span class="n">GENERIC_READ</span><span class="p">,</span>
                                          <span class="n">win32file</span><span class="o">.</span><span class="n">FILE_SHARE_READ</span> <span class="o">&amp;</span> <span class="n">win32file</span><span class="o">.</span><span class="n">FILE_SHARE_WRITE</span><span class="p">,</span>
                                          <span class="n">attributes</span><span class="p">,</span> <span class="n">disposition</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">pywintypes</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="c1"># Handle native windows errors into python errors to be consistent with the API</span>
            <span class="c1"># of os.open in the situation of a file already existing or locked.</span>
            <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">winerror</span> <span class="o">==</span> <span class="n">winerror</span><span class="o">.</span><span class="n">ERROR_FILE_EXISTS</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EEXIST</span><span class="p">,</span> <span class="n">err</span><span class="o">.</span><span class="n">strerror</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">winerror</span> <span class="o">==</span> <span class="n">winerror</span><span class="o">.</span><span class="n">ERROR_SHARING_VIOLATION</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EACCES</span><span class="p">,</span> <span class="n">err</span><span class="o">.</span><span class="n">strerror</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">err</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">handle</span><span class="p">:</span>
                <span class="n">handle</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>

        <span class="c1"># At this point, the file that did not exist has been created with proper permissions,</span>
        <span class="c1"># so os.O_CREAT and os.O_EXCL are not needed anymore. We remove them from the flags to</span>
        <span class="c1"># avoid a FileExists exception before calling os.open.</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">flags</span> <span class="o">^</span> <span class="n">os</span><span class="o">.</span><span class="n">O_CREAT</span> <span class="o">^</span> <span class="n">os</span><span class="o">.</span><span class="n">O_EXCL</span><span class="p">)</span>

    <span class="c1"># Windows: general case, we call os.open, let exceptions be thrown, then chmod if all is fine.</span>
    <span class="n">handle</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
    <span class="n">chmod</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">handle</span></div>


<div class="viewcode-block" id="makedirs"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.makedirs">[docs]</a><span class="k">def</span> <span class="nf">makedirs</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mo">0o777</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rewrite of original os.makedirs function, that will ensure on Windows that given mode</span>
<span class="sd">    is correctly applied.</span>

<span class="sd">    :param str file_path: The file path to open</span>
<span class="sd">    :param int mode: POSIX mode to apply on leaf directory when created, Python defaults</span>
<span class="sd">                     will be applied if ``None``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">current_umask</span> <span class="o">=</span> <span class="n">umask</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Since Python 3.7, os.makedirs does not set the given mode to the intermediate</span>
        <span class="c1"># directories that could be created in the process. To keep things safe and consistent</span>
        <span class="c1"># on all Python versions, we set the umask accordingly to have all directories</span>
        <span class="c1"># (intermediate and leaf) created with the given mode.</span>
        <span class="n">umask</span><span class="p">(</span><span class="n">current_umask</span> <span class="o">|</span> <span class="mo">0o777</span> <span class="o">^</span> <span class="n">mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

        <span class="n">orig_mkdir_fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># As we know that os.mkdir is called internally by os.makedirs, we will swap the</span>
            <span class="c1"># function in os module for the time of makedirs execution on Windows.</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span> <span class="o">=</span> <span class="n">mkdir</span>  <span class="c1"># type: ignore</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span> <span class="o">=</span> <span class="n">orig_mkdir_fn</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">umask</span><span class="p">(</span><span class="n">current_umask</span><span class="p">)</span></div>


<div class="viewcode-block" id="mkdir"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.mkdir">[docs]</a><span class="k">def</span> <span class="nf">mkdir</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mo">0o777</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rewrite of original os.mkdir function, that will ensure on Windows that given mode</span>
<span class="sd">    is correctly applied.</span>

<span class="sd">    :param str file_path: The file path to open</span>
<span class="sd">    :param int mode: POSIX mode to apply on directory when created, Python defaults</span>
<span class="sd">                     will be applied if ``None``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="n">attributes</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">SECURITY_ATTRIBUTES</span><span class="p">()</span>
    <span class="n">security</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">SECURITY_DESCRIPTOR</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">_get_current_user</span><span class="p">()</span>
    <span class="n">dacl</span> <span class="o">=</span> <span class="n">_generate_dacl</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">_WINDOWS_UMASK</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">security</span><span class="o">.</span><span class="n">SetSecurityDescriptorOwner</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">security</span><span class="o">.</span><span class="n">SetSecurityDescriptorDacl</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dacl</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">win32file</span><span class="o">.</span><span class="n">CreateDirectory</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">attributes</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">pywintypes</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="c1"># Handle native windows error into python error to be consistent with the API</span>
        <span class="c1"># of os.mkdir in the situation of a directory already existing.</span>
        <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">winerror</span> <span class="o">==</span> <span class="n">winerror</span><span class="o">.</span><span class="n">ERROR_ALREADY_EXISTS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="n">errno</span><span class="o">.</span><span class="n">EEXIST</span><span class="p">,</span> <span class="n">err</span><span class="o">.</span><span class="n">strerror</span><span class="p">,</span> <span class="n">file_path</span><span class="p">,</span> <span class="n">err</span><span class="o">.</span><span class="n">winerror</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">err</span>

    <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="replace"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.replace">[docs]</a><span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dst</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rename a file to a destination path and handles situations where the destination exists.</span>

<span class="sd">    :param str src: The current file path.</span>
<span class="sd">    :param str dst: The new file path.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">):</span>
        <span class="c1"># Use replace if possible. Since we don&#39;t support Python 2 on Windows</span>
        <span class="c1"># and os.replace() was added in Python 3.3, we can assume that</span>
        <span class="c1"># os.replace() is always available on Windows.</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Otherwise, use os.rename() that behaves like os.replace() on Linux.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span></div>


<div class="viewcode-block" id="realpath"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.realpath">[docs]</a><span class="k">def</span> <span class="nf">realpath</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the real path for the given path. This method resolves symlinks, including</span>
<span class="sd">    recursive symlinks, and is protected against symlinks that creates an infinite loop.</span>

<span class="sd">    :param str file_path: The path to resolve</span>
<span class="sd">    :returns: The real path for the given path</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_path</span> <span class="o">=</span> <span class="n">file_path</span>

    <span class="c1"># Since Python 3.8, os.path.realpath also resolves symlinks on Windows.</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span> <span class="ow">or</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">islink</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="c1"># If path returned by realpath is still a link, it means that it failed to</span>
            <span class="c1"># resolve the symlink because of a loop.</span>
            <span class="c1"># See realpath code: https://github.com/python/cpython/blob/master/Lib/posixpath.py</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Error, link </span><span class="si">{0}</span><span class="s1"> is a loop!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">original_path</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">path</span>

    <span class="n">inspected_paths</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">islink</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
        <span class="n">link_path</span> <span class="o">=</span> <span class="n">file_path</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">readlink</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">link_path</span><span class="p">),</span> <span class="n">file_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">file_path</span> <span class="ow">in</span> <span class="n">inspected_paths</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Error, link </span><span class="si">{0}</span><span class="s1"> is a loop!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">original_path</span><span class="p">))</span>
        <span class="n">inspected_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span></div>


<div class="viewcode-block" id="readlink"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.readlink">[docs]</a><span class="k">def</span> <span class="nf">readlink</span><span class="p">(</span><span class="n">link_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string representing the path to which the symbolic link points.</span>

<span class="sd">    :param str link_path: The symlink path to resolve</span>
<span class="sd">    :return: The path the symlink points to</span>
<span class="sd">    :returns: str</span>
<span class="sd">    :raise: ValueError if a long path (260&gt; characters) is encountered on Windows</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">readlink</span><span class="p">(</span><span class="n">link_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">POSIX_MODE</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\\\</span><span class="s1">?</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">path</span>

    <span class="c1"># At this point, we know we are on Windows and that the path returned uses</span>
    <span class="c1"># the extended form which is done for all paths in Python 3.8+</span>

    <span class="c1"># Max length of a normal path is 260 characters on Windows, including the non printable</span>
    <span class="c1"># termination character &quot;&lt;NUL&gt;&quot;. The termination character is not included in Python</span>
    <span class="c1"># strings, giving a max length of 259 characters, + 4 characters for the extended form</span>
    <span class="c1"># prefix, to an effective max length 263 characters on a string representing a normal path.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">264</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Long paths are not supported by Certbot on Windows.&quot;</span><span class="p">)</span></div>


<span class="c1"># On Windows is_executable run from an unprivileged shell may claim that a path is</span>
<span class="c1"># executable when it is executable only if run from a privileged shell. This result</span>
<span class="c1"># is due to the fact that GetEffectiveRightsFromAcl calculate effective rights</span>
<span class="c1"># without taking into consideration if the target user has currently required the</span>
<span class="c1"># elevated privileges or not. However this is not a problem since certbot always</span>
<span class="c1"># requires to be run under a privileged shell, so the user will always benefit</span>
<span class="c1"># from the highest (privileged one) set of permissions on a given file.</span>
<div class="viewcode-block" id="is_executable"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.is_executable">[docs]</a><span class="k">def</span> <span class="nf">is_executable</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is path an executable file?</span>

<span class="sd">    :param str path: path to test</span>
<span class="sd">    :return: True if path is an executable file</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">X_OK</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_win_is_executable</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>


<div class="viewcode-block" id="has_world_permissions"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.has_world_permissions">[docs]</a><span class="k">def</span> <span class="nf">has_world_permissions</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if everybody/world has any right (read/write/execute) on a file given its path.</span>

<span class="sd">    :param str path: path to test</span>
<span class="sd">    :return: True if everybody/world has any right to the file</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IMODE</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IRWXO</span><span class="p">)</span>

    <span class="n">security</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">DACL_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="n">dacl</span> <span class="o">=</span> <span class="n">security</span><span class="o">.</span><span class="n">GetSecurityDescriptorDacl</span><span class="p">()</span>

    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">dacl</span><span class="o">.</span><span class="n">GetEffectiveRightsFromAcl</span><span class="p">({</span>
        <span class="s1">&#39;TrusteeForm&#39;</span><span class="p">:</span> <span class="n">win32security</span><span class="o">.</span><span class="n">TRUSTEE_IS_SID</span><span class="p">,</span>
        <span class="s1">&#39;TrusteeType&#39;</span><span class="p">:</span> <span class="n">win32security</span><span class="o">.</span><span class="n">TRUSTEE_IS_USER</span><span class="p">,</span>
        <span class="s1">&#39;Identifier&#39;</span><span class="p">:</span> <span class="n">win32security</span><span class="o">.</span><span class="n">ConvertStringSidToSid</span><span class="p">(</span><span class="s1">&#39;S-1-1-0&#39;</span><span class="p">),</span>
    <span class="p">}))</span></div>


<div class="viewcode-block" id="compute_private_key_mode"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.compute_private_key_mode">[docs]</a><span class="k">def</span> <span class="nf">compute_private_key_mode</span><span class="p">(</span><span class="n">old_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">base_mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the POSIX mode to apply to a private key given the previous private key.</span>

<span class="sd">    :param str old_key: path to the previous private key</span>
<span class="sd">    :param int base_mode: the minimum modes to apply to a private key</span>
<span class="sd">    :return: the POSIX mode to apply</span>
<span class="sd">    :rtype: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="c1"># On Linux, we keep read/write/execute permissions</span>
        <span class="c1"># for group and read permissions for everybody.</span>
        <span class="n">old_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IMODE</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">old_key</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span> <span class="o">&amp;</span>
                    <span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">S_IRGRP</span> <span class="o">|</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IWGRP</span> <span class="o">|</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXGRP</span> <span class="o">|</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IROTH</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">base_mode</span> <span class="o">|</span> <span class="n">old_mode</span>

    <span class="c1"># On Windows, the mode returned by os.stat is not reliable,</span>
    <span class="c1"># so we do not keep any permission from the previous private key.</span>
    <span class="k">return</span> <span class="n">base_mode</span></div>


<div class="viewcode-block" id="has_same_ownership"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.has_same_ownership">[docs]</a><span class="k">def</span> <span class="nf">has_same_ownership</span><span class="p">(</span><span class="n">path1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">path2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if the ownership of two files given their respective path is the same.</span>
<span class="sd">    On Windows, ownership is checked against owner only, since files do not have a group owner.</span>

<span class="sd">    :param str path1: path to the first file</span>
<span class="sd">    :param str path2: path to the second file</span>
<span class="sd">    :return: True if both files have the same ownership, False otherwise</span>
<span class="sd">    :rtype: bool</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="n">stats1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path1</span><span class="p">)</span>
        <span class="n">stats2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">stats1</span><span class="o">.</span><span class="n">st_uid</span><span class="p">,</span> <span class="n">stats1</span><span class="o">.</span><span class="n">st_gid</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">stats2</span><span class="o">.</span><span class="n">st_uid</span><span class="p">,</span> <span class="n">stats2</span><span class="o">.</span><span class="n">st_gid</span><span class="p">)</span>

    <span class="n">security1</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">OWNER_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="n">user1</span> <span class="o">=</span> <span class="n">security1</span><span class="o">.</span><span class="n">GetSecurityDescriptorOwner</span><span class="p">()</span>

    <span class="n">security2</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span><span class="n">path2</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">OWNER_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="n">user2</span> <span class="o">=</span> <span class="n">security2</span><span class="o">.</span><span class="n">GetSecurityDescriptorOwner</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">user1</span> <span class="o">==</span> <span class="n">user2</span></div>


<div class="viewcode-block" id="has_min_permissions"><a class="viewcode-back" href="../../../api/certbot.compat.filesystem.html#certbot.compat.filesystem.has_min_permissions">[docs]</a><span class="k">def</span> <span class="nf">has_min_permissions</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">min_mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if a file given its path has at least the permissions defined by the given minimal mode.</span>
<span class="sd">    On Windows, group permissions are ignored since files do not have a group owner.</span>

<span class="sd">    :param str path: path to the file to check</span>
<span class="sd">    :param int min_mode: the minimal permissions expected</span>
<span class="sd">    :return: True if the file matches the minimal permissions expectations, False otherwise</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">POSIX_MODE</span><span class="p">:</span>
        <span class="n">st_mode</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span>
        <span class="k">return</span> <span class="n">st_mode</span> <span class="o">==</span> <span class="n">st_mode</span> <span class="o">|</span> <span class="n">min_mode</span>

    <span class="c1"># Resolve symlinks, to get a consistent result with os.stat on Linux,</span>
    <span class="c1"># that follows symlinks by default.</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="c1"># Get owner sid of the file</span>
    <span class="n">security</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span>
        <span class="n">path</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">OWNER_SECURITY_INFORMATION</span> <span class="o">|</span> <span class="n">win32security</span><span class="o">.</span><span class="n">DACL_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">security</span><span class="o">.</span><span class="n">GetSecurityDescriptorOwner</span><span class="p">()</span>
    <span class="n">dacl</span> <span class="o">=</span> <span class="n">security</span><span class="o">.</span><span class="n">GetSecurityDescriptorDacl</span><span class="p">()</span>
    <span class="n">min_dacl</span> <span class="o">=</span> <span class="n">_generate_dacl</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">min_mode</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_dacl</span><span class="o">.</span><span class="n">GetAceCount</span><span class="p">()):</span>
        <span class="n">min_ace</span> <span class="o">=</span> <span class="n">min_dacl</span><span class="o">.</span><span class="n">GetAce</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># On a given ACE, index 0 is the ACE type, 1 is the permission mask, and 2 is the SID.</span>
        <span class="c1"># See: http://timgolden.me.uk/pywin32-docs/PyACL__GetAce_meth.html</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">min_ace</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">min_ace</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">effective_mask</span> <span class="o">=</span> <span class="n">dacl</span><span class="o">.</span><span class="n">GetEffectiveRightsFromAcl</span><span class="p">({</span>
            <span class="s1">&#39;TrusteeForm&#39;</span><span class="p">:</span> <span class="n">win32security</span><span class="o">.</span><span class="n">TRUSTEE_IS_SID</span><span class="p">,</span>
            <span class="s1">&#39;TrusteeType&#39;</span><span class="p">:</span> <span class="n">win32security</span><span class="o">.</span><span class="n">TRUSTEE_IS_USER</span><span class="p">,</span>
            <span class="s1">&#39;Identifier&#39;</span><span class="p">:</span> <span class="n">user</span><span class="p">,</span>
        <span class="p">})</span>

        <span class="k">if</span> <span class="n">effective_mask</span> <span class="o">!=</span> <span class="n">effective_mask</span> <span class="o">|</span> <span class="n">mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span></div>


<span class="k">def</span> <span class="nf">_win_is_executable</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">security</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">DACL_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="n">dacl</span> <span class="o">=</span> <span class="n">security</span><span class="o">.</span><span class="n">GetSecurityDescriptorDacl</span><span class="p">()</span>

    <span class="n">mode</span> <span class="o">=</span> <span class="n">dacl</span><span class="o">.</span><span class="n">GetEffectiveRightsFromAcl</span><span class="p">({</span>
        <span class="s1">&#39;TrusteeForm&#39;</span><span class="p">:</span> <span class="n">win32security</span><span class="o">.</span><span class="n">TRUSTEE_IS_SID</span><span class="p">,</span>
        <span class="s1">&#39;TrusteeType&#39;</span><span class="p">:</span> <span class="n">win32security</span><span class="o">.</span><span class="n">TRUSTEE_IS_USER</span><span class="p">,</span>
        <span class="s1">&#39;Identifier&#39;</span><span class="p">:</span> <span class="n">_get_current_user</span><span class="p">(),</span>
    <span class="p">})</span>

    <span class="k">return</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">ntsecuritycon</span><span class="o">.</span><span class="n">FILE_GENERIC_EXECUTE</span> <span class="o">==</span> <span class="n">ntsecuritycon</span><span class="o">.</span><span class="n">FILE_GENERIC_EXECUTE</span>


<span class="k">def</span> <span class="nf">_apply_win_mode</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function converts the given POSIX mode into a Windows ACL list, and applies it to the</span>
<span class="sd">    file given its path. If the given path is a symbolic link, it will resolved to apply the</span>
<span class="sd">    mode on the targeted file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">file_path</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
    <span class="c1"># Get owner sid of the file</span>
    <span class="n">security</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">OWNER_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">security</span><span class="o">.</span><span class="n">GetSecurityDescriptorOwner</span><span class="p">()</span>

    <span class="c1"># New DACL, that will overwrite existing one (including inherited permissions)</span>
    <span class="n">dacl</span> <span class="o">=</span> <span class="n">_generate_dacl</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="c1"># Apply the new DACL</span>
    <span class="n">security</span><span class="o">.</span><span class="n">SetSecurityDescriptorDacl</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dacl</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">win32security</span><span class="o">.</span><span class="n">SetFileSecurity</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">DACL_SECURITY_INFORMATION</span><span class="p">,</span> <span class="n">security</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_generate_dacl</span><span class="p">(</span><span class="n">user_sid</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mo">0o777</span> <span class="o">-</span> <span class="n">mask</span><span class="p">)</span>
    <span class="n">analysis</span> <span class="o">=</span> <span class="n">_analyze_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

    <span class="c1"># Get standard accounts from &quot;well-known&quot; sid</span>
    <span class="c1"># See the list here:</span>
    <span class="c1"># https://support.microsoft.com/en-us/help/243330/well-known-security-identifiers-in-windows-operating-systems</span>
    <span class="n">system</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">ConvertStringSidToSid</span><span class="p">(</span><span class="s1">&#39;S-1-5-18&#39;</span><span class="p">)</span>
    <span class="n">admins</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">ConvertStringSidToSid</span><span class="p">(</span><span class="s1">&#39;S-1-5-32-544&#39;</span><span class="p">)</span>
    <span class="n">everyone</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">ConvertStringSidToSid</span><span class="p">(</span><span class="s1">&#39;S-1-1-0&#39;</span><span class="p">)</span>

    <span class="c1"># New dacl, without inherited permissions</span>
    <span class="n">dacl</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">ACL</span><span class="p">()</span>

    <span class="c1"># If user is already system or admins, any ACE defined here would be superseded by</span>
    <span class="c1"># the full control ACE that will be added after.</span>
    <span class="k">if</span> <span class="n">user_sid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">system</span><span class="p">,</span> <span class="n">admins</span><span class="p">]:</span>
        <span class="c1"># Handle user rights</span>
        <span class="n">user_flags</span> <span class="o">=</span> <span class="n">_generate_windows_flags</span><span class="p">(</span><span class="n">analysis</span><span class="p">[</span><span class="s1">&#39;user&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">user_flags</span><span class="p">:</span>
            <span class="n">dacl</span><span class="o">.</span><span class="n">AddAccessAllowedAce</span><span class="p">(</span><span class="n">win32security</span><span class="o">.</span><span class="n">ACL_REVISION</span><span class="p">,</span> <span class="n">user_flags</span><span class="p">,</span> <span class="n">user_sid</span><span class="p">)</span>

    <span class="c1"># Handle everybody rights</span>
    <span class="n">everybody_flags</span> <span class="o">=</span> <span class="n">_generate_windows_flags</span><span class="p">(</span><span class="n">analysis</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">everybody_flags</span><span class="p">:</span>
        <span class="n">dacl</span><span class="o">.</span><span class="n">AddAccessAllowedAce</span><span class="p">(</span><span class="n">win32security</span><span class="o">.</span><span class="n">ACL_REVISION</span><span class="p">,</span> <span class="n">everybody_flags</span><span class="p">,</span> <span class="n">everyone</span><span class="p">)</span>

    <span class="c1"># Handle administrator rights</span>
    <span class="n">full_permissions</span> <span class="o">=</span> <span class="n">_generate_windows_flags</span><span class="p">({</span><span class="s1">&#39;read&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;write&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;execute&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
    <span class="n">dacl</span><span class="o">.</span><span class="n">AddAccessAllowedAce</span><span class="p">(</span><span class="n">win32security</span><span class="o">.</span><span class="n">ACL_REVISION</span><span class="p">,</span> <span class="n">full_permissions</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>
    <span class="n">dacl</span><span class="o">.</span><span class="n">AddAccessAllowedAce</span><span class="p">(</span><span class="n">win32security</span><span class="o">.</span><span class="n">ACL_REVISION</span><span class="p">,</span> <span class="n">full_permissions</span><span class="p">,</span> <span class="n">admins</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dacl</span>


<span class="k">def</span> <span class="nf">_analyze_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;read&#39;</span><span class="p">:</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IRUSR</span><span class="p">,</span>
            <span class="s1">&#39;write&#39;</span><span class="p">:</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IWUSR</span><span class="p">,</span>
            <span class="s1">&#39;execute&#39;</span><span class="p">:</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXUSR</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;read&#39;</span><span class="p">:</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IROTH</span><span class="p">,</span>
            <span class="s1">&#39;write&#39;</span><span class="p">:</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IWOTH</span><span class="p">,</span>
            <span class="s1">&#39;execute&#39;</span><span class="p">:</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">stat</span><span class="o">.</span><span class="n">S_IXOTH</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">}</span>


<span class="k">def</span> <span class="nf">_copy_win_ownership</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
    <span class="c1"># Resolve symbolic links</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

    <span class="n">security_src</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">OWNER_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="n">user_src</span> <span class="o">=</span> <span class="n">security_src</span><span class="o">.</span><span class="n">GetSecurityDescriptorOwner</span><span class="p">()</span>

    <span class="n">security_dst</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">OWNER_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="c1"># Second parameter indicates, if `False`, that the owner of the file is not provided by some</span>
    <span class="c1"># default mechanism, but is explicitly set instead. This is obviously what we are doing here.</span>
    <span class="n">security_dst</span><span class="o">.</span><span class="n">SetSecurityDescriptorOwner</span><span class="p">(</span><span class="n">user_src</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="n">win32security</span><span class="o">.</span><span class="n">SetFileSecurity</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">OWNER_SECURITY_INFORMATION</span><span class="p">,</span> <span class="n">security_dst</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_copy_win_mode</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
    <span class="c1"># Resolve symbolic links</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

    <span class="c1"># Copy the DACL from src to dst.</span>
    <span class="n">security_src</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">DACL_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="n">dacl</span> <span class="o">=</span> <span class="n">security_src</span><span class="o">.</span><span class="n">GetSecurityDescriptorDacl</span><span class="p">()</span>

    <span class="n">security_dst</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">DACL_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="n">security_dst</span><span class="o">.</span><span class="n">SetSecurityDescriptorDacl</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dacl</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">win32security</span><span class="o">.</span><span class="n">SetFileSecurity</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">DACL_SECURITY_INFORMATION</span><span class="p">,</span> <span class="n">security_dst</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_generate_windows_flags</span><span class="p">(</span><span class="n">rights_desc</span><span class="p">):</span>
    <span class="c1"># Some notes about how each POSIX right is interpreted.</span>
    <span class="c1">#</span>
    <span class="c1"># For the rights read and execute, we have a pretty bijective relation between</span>
    <span class="c1"># POSIX flags and their generic counterparts on Windows, so we use them directly</span>
    <span class="c1"># (respectively ntsecuritycon.FILE_GENERIC_READ and ntsecuritycon.FILE_GENERIC_EXECUTE).</span>
    <span class="c1">#</span>
    <span class="c1"># But ntsecuritycon.FILE_GENERIC_WRITE does not correspond to what one could expect from a</span>
    <span class="c1"># write access on Linux: for Windows, FILE_GENERIC_WRITE does not include delete, move or</span>
    <span class="c1"># rename. This is something that requires ntsecuritycon.FILE_ALL_ACCESS.</span>
    <span class="c1"># So to reproduce the write right as POSIX, we will apply ntsecuritycon.FILE_ALL_ACCESS</span>
    <span class="c1"># subtracted of the rights corresponding to POSIX read and POSIX execute.</span>
    <span class="c1">#</span>
    <span class="c1"># Finally, having read + write + execute gives a ntsecuritycon.FILE_ALL_ACCESS,</span>
    <span class="c1"># so a &quot;Full Control&quot; on the file.</span>
    <span class="c1">#</span>
    <span class="c1"># A complete list of the rights defined on NTFS can be found here:</span>
    <span class="c1"># https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc783530(v=ws.10)#permissions-for-files-and-folders</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">rights_desc</span><span class="p">[</span><span class="s1">&#39;read&#39;</span><span class="p">]:</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">|</span> <span class="n">ntsecuritycon</span><span class="o">.</span><span class="n">FILE_GENERIC_READ</span>
    <span class="k">if</span> <span class="n">rights_desc</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]:</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">|</span> <span class="p">(</span><span class="n">ntsecuritycon</span><span class="o">.</span><span class="n">FILE_ALL_ACCESS</span>
                       <span class="o">^</span> <span class="n">ntsecuritycon</span><span class="o">.</span><span class="n">FILE_GENERIC_READ</span>
                       <span class="o">^</span> <span class="n">ntsecuritycon</span><span class="o">.</span><span class="n">FILE_GENERIC_EXECUTE</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rights_desc</span><span class="p">[</span><span class="s1">&#39;execute&#39;</span><span class="p">]:</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">|</span> <span class="n">ntsecuritycon</span><span class="o">.</span><span class="n">FILE_GENERIC_EXECUTE</span>

    <span class="k">return</span> <span class="n">flag</span>


<span class="k">def</span> <span class="nf">_check_win_mode</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="c1"># Resolve symbolic links</span>
    <span class="n">file_path</span> <span class="o">=</span> <span class="n">realpath</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
    <span class="c1"># Get current dacl file</span>
    <span class="n">security</span> <span class="o">=</span> <span class="n">win32security</span><span class="o">.</span><span class="n">GetFileSecurity</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">win32security</span><span class="o">.</span><span class="n">OWNER_SECURITY_INFORMATION</span>
                                             <span class="o">|</span> <span class="n">win32security</span><span class="o">.</span><span class="n">DACL_SECURITY_INFORMATION</span><span class="p">)</span>
    <span class="n">dacl</span> <span class="o">=</span> <span class="n">security</span><span class="o">.</span><span class="n">GetSecurityDescriptorDacl</span><span class="p">()</span>

    <span class="c1"># Get current file owner sid</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">security</span><span class="o">.</span><span class="n">GetSecurityDescriptorOwner</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dacl</span><span class="p">:</span>
        <span class="c1"># No DACL means full control to everyone</span>
        <span class="c1"># This is not a deterministic permissions set.</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Calculate the target dacl</span>
    <span class="n">ref_dacl</span> <span class="o">=</span> <span class="n">_generate_dacl</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_compare_dacls</span><span class="p">(</span><span class="n">dacl</span><span class="p">,</span> <span class="n">ref_dacl</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_compare_dacls</span><span class="p">(</span><span class="n">dacl1</span><span class="p">,</span> <span class="n">dacl2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method compare the two given DACLs to check if they are identical.</span>
<span class="sd">    Identical means here that they contains the same set of ACEs in the same order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">([</span><span class="n">dacl1</span><span class="o">.</span><span class="n">GetAce</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dacl1</span><span class="o">.</span><span class="n">GetAceCount</span><span class="p">())]</span> <span class="o">==</span>
            <span class="p">[</span><span class="n">dacl2</span><span class="o">.</span><span class="n">GetAce</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dacl2</span><span class="o">.</span><span class="n">GetAceCount</span><span class="p">())])</span>


<span class="k">def</span> <span class="nf">_get_current_user</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the pySID corresponding to the current user.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We craft the account_name ourselves instead of calling for instance win32api.GetUserNameEx,</span>
    <span class="c1"># because this function returns nonsense values when Certbot is run under NT AUTHORITY\SYSTEM.</span>
    <span class="c1"># To run Certbot under NT AUTHORITY\SYSTEM, you can open a shell using the instructions here:</span>
    <span class="c1"># https://blogs.technet.microsoft.com/ben_parker/2010/10/27/how-do-i-run-powershell-execommand-prompt-as-the-localsystem-account-on-windows-7/</span>
    <span class="n">account_name</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">\</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">win32api</span><span class="o">.</span><span class="n">GetDomainName</span><span class="p">(),</span> <span class="n">win32api</span><span class="o">.</span><span class="n">GetUserName</span><span class="p">())</span>
    <span class="c1"># LookupAccountName() expects the system name as first parameter. By passing None to it,</span>
    <span class="c1"># we instruct Windows to first search the matching account in the machine local accounts,</span>
    <span class="c1"># then into the primary domain accounts, if the machine has joined a domain, then finally</span>
    <span class="c1"># into the trusted domains accounts. This is the preferred lookup mechanism to use in Windows</span>
    <span class="c1"># if there is no reason to use a specific lookup mechanism.</span>
    <span class="c1"># See https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-lookupaccountnamea</span>
    <span class="k">return</span> <span class="n">win32security</span><span class="o">.</span><span class="n">LookupAccountName</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">account_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
    <span class="copyright">
    &copy; Copyright 2014-2018 - The Certbot software and documentation are licensed under the Apache 2.0 license as described at <a href="https://eff.org/cb-license">https://eff.org/cb-license</a>.
    </span>
    <br>
    <br>
    <span class="status">
        <a href="https://letsencrypt.status.io/">Let's Encrypt Status</a>
    </span>

    </p>
  </div>
  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>